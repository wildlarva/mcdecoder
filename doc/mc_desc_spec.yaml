# Specification of machine code description file
#
# Machine code description file needs to be a YAML format.

# Describes a machine
machine:
  decoder: # [optional] Decoder information for the machine
    namespace: ns # [optional] Namespace for the symbols of a generated decoder

    extras: # [optional] Container of user-defined data for the machine
      # Any structure can be defined here
      arch_type: arm

# Describes instructions
#
# Each list element represents an instruction.
instructions:
  - name: add_1 # Name of the instruction

    # Encoding format of the instruction
    #
    # Instruction fields are separated by bar symbol(|).
    #
    # <field_bits>:<field_name>[<field_bit_ranges>]|...
    #
    # where
    #   <field_bits>: Encoding format of an instruction field
    #     It takes an array of 0, 1, or x.
    #     '0' or '1' represents a fixed bit of the instruction field. 'x' represents any bit.
    #
    #   <field_name>: [optional] Name of the instruction field
    #     NOTE: One field name can be used multiple times in one instruction.
    #           This constructs subfields of a field split into several bit ranges.
    #
    #   <field_bit_ranges>: [optional] Field bit ranges of an instruction field
    #     Each bit range expresses a subfield of the field.
    #     Subfields are separated by comma symbol(,).
    #     Its format is <subfield_start>:<subfield_end>,...
    #
    #   <subfield_start>: Subfield start bit position in the instruction field
    #     NOTE: This is a start bit position in a field, not in an instruction.
    #
    #   <subfield_end>: [optional] Subfield end bit position in the instruction field
    #     NOTE: This is an end bit position in a field, not in an instruction.
    format: xxxx:cond|00|1|0100|x:S|xxxx:Rn|xxxx:Rd|xxxxxxxxxxxx:imm12

    # [optional] Bit condition when the instruction applys
    #
    # Each mapping key represents a field used for a condition and its value represents the condition itself.
    # If multiple field conditions are defined, they're combined with AND operator.
    #
    # The following condition types are supported.
    # - Equality: The equality between a field value and a given value.
    #     Its expression is '<operator> <value>'.
    # - In Range: A field value is in a given value range(inclusive) or not.
    #     Its expression is 'in_range <value_start>-<value_end>'.
    #
    # where
    #   <operator>: An equality operator to check.
    #     It can be !=, <, <=, > or >=.
    #
    #   <value>: A value to check the equality
    #     10-base integer values like 1, 2, 10, etc.
    #
    #   <value_start>: The start of a value range(inclusive)
    #     10-base integer values like 1, 2, 10, etc.
    #
    #   <value_end>: The end of a value range(inclusive)
    #     10-base integer values like 1, 2, 10, etc.
    #
    # NOTE: You have to wrap your conditional expression with quotes when you use ! or > as the first letter of a condition.
    #       This is a restriction of YAML format.
    condition:
      cond: in_range 0-14

    extras: # [optional] Container of user-defined data for the instruction
      # Any structure can be defined here
      clocks: 10

  - name: push_1
    format: xxxx:cond|100100|1|0|1101|xxxxxxxxxxxxxxxx:register_list
    condition:
      cond: '!= 15'

  - name: c_addi_1
    format: 000:funct3|x:imm[5]|xxxxx:dest|xxxxx:imm[4:0]|01:op

  - name: c_sd_1
    format: 111:funct3|xxxxxx:offset[5:3,8:6]|xxxxx:src|10:op
